## Search in a Rotated Array
Since binary search operates in `O(log(n))` time, we just need to figure out a way to apply it here. The additional wrinkle is that binary search assumes a pre-sorted array, and we have a pivoted array. Most sorting algorithms operate in at least `O(nlogn)` time in the best case, so resorting the array is too expensive, per the requirements. Thankfully, the pivoted array is just one step away from being sorted. We can think of it as two sorted binary arrays whose ranges do not overlap and are concatenated together. We just need to pick the one on which to perform binary search in either `O(n)` or `O(log(n))` time.

Picking one side of the pivot or another requires finding the pivot. We can think of this as a variation on binary search, except instead of comparing our midpoint value to pre-specified target value, we are comparing the midpoint to its two neighbors. If it is larger than its right neighbor, it is the pivot. If it's smaller than its left neighbor, then its left neighbor is the pivot. Since binary search requires us to discard one partition of the array, how can we on which side of the midpoint we need to look? If the first value of the array is larger than the midpoint, we know that the pivot point lies somewhere before the midpoint. If the first value of the array is smaller than the midpoint, then we know the pivot happens after the midpoint.

Even though the problem specifies that the input is a pivoted, presorted array, the function will enter an infinite recursion looking for the pivot if the array isn't actually pivoted, so I wrote a base case that returns `-1` if no pivot exists. There are alternative ways to handle that, of course.

The overall time complexity should be `O(log(n))`, because we are essentially conducting two sequential binary searches, which each take `O(log(n))` time. The worst case scenario is that the pivot is the last element (i.e., it's not really pivoted, but already presortored, although we still are checking to find the pivot).  So, that yields a time complexity of`O(log(n)) + O(log(n))`, which simplifies to `O(2*log(n))`. Since we are only focused on the highest-order term, we are still operating at `O(log(n))`.

Space complexity is `O(log(n))` in the worst case, because we implemented the binary search recursively in both cases. Each time we we make a recursive call we are placing the current invocation on the stack. When we're `k` levels deep, we have `k` calls on the stack, so the space complexity ends up being proportional to the depth we can search. The binary search tree we build from a sorted array should always be balanced, since we are starting from the middle element.
